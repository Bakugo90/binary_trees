#include "binary_trees.h"

/**
 * binary_tree_full - node full
 * @tree: node
 * Return: int
*/
int binary_tree_is_full(const binary_tree_t *tree)
{
if (tree == NULL)
return (1);
if ((tree->left != NULL && tree->right == NULL) ||
(tree->left == NULL && tree->right != NULL) ||
binary_tree_is_full(tree->left) ||
binary_tree_is_full(tree->right))
return (0);

return (1);
}

/**
 * binary_tree_depth - deep
 * @tree: node
 * Return: unsigned int
*/
int binary_tree_dept(const binary_tree_t *tree)
{
if (tree == NULL || tree->parent == NULL)
return (0);
return (1 + (binary_tree_dept(tree->parent)));
}

binary_tree_t *freez(const binary_tree_t *tree)
{
if (tree == NULL)
return (NULL);
if (tree->left == NULL && tree->right == NULL)
return (binary_tree_t *)tree;
else
return ((tree->left) ? freez(tree->left) : freez(tree->right));
}


int binary_tree_or(const binary_tree_t *tree,int n)
{
if ((tree->left != NULL && tree->right == NULL) ||
(tree->left == NULL && tree->right != NULL))
return (0);
return (1);

}

/**
 * binary_tree_preorder - pre order traversal
 * @tree: node root
 * @func: function apply over node
*/
int binary_tree_preorde(const binary_tree_t *tree, int n)
{
int p;
if (tree == NULL)
return (0);
p = binary_tree_or(tree, n);
if (p == 0)
return (0);
binary_tree_preorde(tree->left, n);
binary_tree_preorde(tree->right, n);
}


/**
 * binary_tree_is_perfect - tree perfect
 * @tree: node
 * Return: integer (0 or 1)
*/
int binary_tree_is_perfect(const binary_tree_t *tree)
{
int n;
if (binary_tree_is_full(tree) == 0)
return (0);
n = binary_tree_dept(freez(tree));
return (binary_tree_preorde(tree, n));
}

